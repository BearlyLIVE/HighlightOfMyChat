<html>

<head>
  <title>Highlighted Messages on Stream!</title>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135113520-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-135113520-1');
  </script>
  <script src="web/comfy.min.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Hind|Open+Sans&display=swap" rel="stylesheet">
  <style>
    h2 { font-family: 'Hind', sans-serif; font-size: 5vw; margin: 0; padding: 0; }
    p { margin: 0; padding: 0; }
    body { font-family: 'Open Sans', sans-serif; font-size: 4vw; color: white; height: 100%; }
    .parent-container {
      height: 100%;
      /* vertical-align: bottom; */
    }
    .translucent-bg {
      visibility: hidden;
      padding: 1vw;
      border-radius: 2px;
      background: rgba( 0, 0, 0, 0.5 );
      position: fixed;
      width: 100%;
    }
    .chat-badges {
      padding: 0.5vw;
    }
    .chat-badge {
      padding: 0.5vw;
    }
  </style>
</head>

<body>
  <div id="parent-container" class="parent-container">
    <div id="highlight-container" class="translucent-bg"><h2><span id="badges"></span> <span id="username"></span></h2><p id="text"></p></div>
  </div>
  <audio id="audio" controls="" style="visibility: hidden;">
    <source id="source" type="audio/wav">
  </audio>
  <script>
    const params = new URLSearchParams( location.search );
    var isTTSEnabled = params.get( "tts" ) || false;
    var ttsVoice = params.get( "voice" ) || "Brian";
    var alignBottom = params.get( "bottom" ) || false;
    var messageId = "";
    var cooldownTimer = null;
    var badgeSets = {};
    function loadBadgeSet( id ) {
    	fetch("https://badges.twitch.tv/v1/badges/global/display?language=en")
      .then( r => r.json() )
      .then( function( data ) {
    		if( data ) {
    			badgeSets = Object.assign( badgeSets, data.badge_sets || {} );
    			fetch( "https://badges.twitch.tv/v1/badges/channels/" + id + "/display?language=en" )
          .then( r => r.json() )
          .then( function( data ) {
    				if( data ) {
    					// Merge the sets together
    					Object.keys( data.badge_sets || {} ).forEach( k => {
    						if( badgeSets[ k ].versions ) {
    							badgeSets[ k ].versions = Object.assign( badgeSets[ k ].versions, data.badge_sets[ k ].versions );
    						}
    						else {
    							badgeSets[ k ] = data.badge_sets[ k ];
    						}
    					});
    				}
    			});
    		}
    	});
    }

    function htmlEntities(html) {
    	function it() {
    		return html.map( function( n, i, arr ) {
    			if( n.length == 1 ) {
    				return n.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
    					return '&#'+i.charCodeAt(0)+';';
    				});
    			}
    			return n;
    		});
    	}
    	var isArray = Array.isArray(html);
    	if( !isArray ) {
    		html = html.split('');
    	}
    	html = it(html);
    	if( !isArray ) {
    		html = html.join('');
    	}
    	return html;
    }

    function formatEmotes(text, emotes) {
    	var splitText = text.split('');
    	for( var i in emotes ) {
    		var e = emotes[i];
    		for( var j in e ) {
    			var mote = e[j];
    			if(typeof mote == 'string') {
    				mote = mote.split('-');
    				mote = [parseInt(mote[0]), parseInt(mote[1])];
    				var length = mote[1] - mote[0];
    				var empty = Array.apply(null, new Array(length + 1)).map(function() { return '' });
    				splitText = splitText.slice(0, mote[0]).concat(empty).concat(splitText.slice(mote[1] + 1, splitText.length));
    				splitText.splice(mote[0], 1, '<img class="chat-message-emote" src="http://static-cdn.jtvnw.net/emoticons/v1/' + i + '/1.0" srcset="https://static-cdn.jtvnw.net/emoticons/v1/' + i + '/1.0 1x,https://static-cdn.jtvnw.net/emoticons/v1/' + i + '/2.0 2x,https://static-cdn.jtvnw.net/emoticons/v1/' + i + '/3.0 4x">');
    			}
    		}
    	}
    	return htmlEntities(splitText).join('')
    }

    function createBadgeFromRole( name, version ) {
    	try {
    		var badge = document.createElement("img");
    		badge.className = "chat-badge";
    		if( badgeSets[ name ] ) {
    			var badgeImage = badgeSets[ name ].versions[ version ];
    			badge.setAttribute( "src", badgeImage.image_url_1x );
    			badge.setAttribute( "srcset", `${badgeImage.image_url_1x} 1x, ${badgeImage.image_url_2x} 2x, ${badgeImage.image_url_4x} 4x` );
    			badge.setAttribute( "alt", badgeImage.title );
    		}
    		return badge;
    	}
    	catch( ex ) {
    		console.log( "Error parsing badge role", name, version );
    		return document.createElement("img");
    	}
    }

    async function highlightThisMessage( user, message, extra ) {
      messageId = extra.id;

      var badges = document.createElement("span");
    	badges.className = "chat-badges";
    	// Add badges based on type
    	if( extra[ "userBadges" ] ) {
    		Object.keys( extra[ "userBadges" ] ).forEach( x => {
    			badges.appendChild( createBadgeFromRole( x, extra[ "userBadges" ][ x ] ) );
    		});
    	}
    	document.querySelector( "#badges" ).innerHTML = badges.innerHTML;
      document.querySelector( "#username" ).innerText = user;
      document.querySelector( "#username" ).style.color = extra.userColor;
      document.querySelector( "#text" ).innerHTML = formatEmotes( message, extra.messageEmotes );
      if( cooldownTimer ) {
        clearTimeout( cooldownTimer );
      }
      document.querySelector( "#highlight-container" ).style.visibility = "visible";
      cooldownTimer = setTimeout( () => {
        document.querySelector( "#highlight-container" ).style.visibility = "hidden";
      }, 30000 );
      if( alignBottom ) {
        document.querySelector( "#highlight-container" ).style.bottom = "0px";
      }

      if( isTTSEnabled ) {
        let speak = await fetch( `https://api.streamelements.com/kappa/v2/speech?voice=${ttsVoice}&text=` + encodeURIComponent( message.trim() ) );
      	if( speak.status != 200 ) {
      		// await speak.text();
      		return;
      	}

        let mp3 = await speak.blob();
        let blobUrl = URL.createObjectURL( mp3 );
      	document.getElementById( "source" ).setAttribute( "src", blobUrl );
      	let audio = document.getElementById( "audio" );
      	audio.pause();
      	audio.load();
        audio.volume = 1;
      	audio.play();
      }
    }

    ComfyJS.onMessageDeleted = ( id, extra ) => {
      if( id === messageId ) {
        // DELETE THE HIGHLIGHTED MESSAGE
        document.querySelector( "#highlight-container" ).style.visibility = "hidden";
      }
    };

    ComfyJS.onChat = ( user, message, flags, self, extra ) => {
      if( flags.highlighted ) {
        highlightThisMessage( user, message, extra );
      }
    };
    ComfyJS.onCommand = ( user, command, message, flags, extra ) => {
      if( flags.highlighted ) {
        highlightThisMessage( user, "!" + command + " " + message, extra );
      }
    };
    ComfyJS.Init( params.get( "channel" ) );
    fetch( "https://api.twitch.tv/helix/users?login=" + params.get( "channel" ), {
      headers: {
        "Client-ID": "2odsv8xermvalbub7wipebrphqlpqv"
      }
    } ).then( r => r.json() )
    .then( data => {
      loadBadgeSet( data.data[ 0 ].id );
    });
  </script>
</body>

</html>
